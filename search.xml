<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css文本尾部标签跟随文本自动换行]]></title>
    <url>%2Farchive%2Ftext-tag-wrap.html</url>
    <content type="text"><![CDATA[在开发中，经常会遇到在title后加一个tag，在title文本过多换行时，要求tag在文本末尾也跟着换行。看起来很简单的样式，其实也不太好实现。借助Array.prototype.split(&#39;&#39;)将title字段没个字都切割出来为一个数组。再遍历数组将没个字单独放在一个div中，tag在所有div之后。最后对父元素做flex布局。display: flex; justify-content: flex-start; align-items: center; flex-wrap: wrap;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Taro绑定小程序map组件踩坑]]></title>
    <url>%2Farchive%2Ftaro-map-regionchange.html</url>
    <content type="text"><![CDATA[坑一：map组件绑定regionchange事件在前一段时间做一个小程序地图选择地点的需求是踩到了一个深坑。给map绑定regionchange事件时，无论我怎么滑动、缩放地图，都不会触发绑定事件，最后在利用了一切搜素引擎后的排查后，发现了mpvue仓库的一个issues，给了我灵感，这个issues里写着：踩坑注意：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将 bind 改为@regionchange,同时这个事件也非常特殊，它的 event type 有 start 和 end 两个，导致我们无法在 handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange=&quot;functionName&quot; @end=&quot;functionName&quot; @start=&quot;functionName&quot;&gt;&lt;map&gt;好家伙，我就抱着试试的态度，我就照着mpvue的文档试了一下，没想到还真成了🙂坑二：regionchange事件取值在进一步的开发中，由于想去分别对拖动地图 和 缩放地图 做不同的操作。所以需要取到regionchange事件event中causedBy的值。好家伙，在开发者工具中event.detail.causedBy取值一切正常，但是在真机调试的时候，却取不到，量在疑惑。后来在手机调试里打印event才发现。开发者工具causedBy在event.detail中。而真机的causedBy，只在event中🙂所以我在event和event.detail中都取了值进行判断。下面附全部map代码：// HTML部分 &lt;map id="mapId" class="map" :markers="markers" :latitude="mapCenterLatitude" :longitude="mapCenterLongitude" :enable-poi="true" :show-location="true" @poitap="changePoi" @markertap="onMarkerTap" @callouttap="onCalloutTap" @regionchange="regionChange" @begin="regionchangeBegin" @end="regionchangeEnd" :style="{ height: activeIpt || searchValue ? 'calc(100vh - 529px)' : 'calc(100vh - 312px)' }" > &lt;view class="local-position"> &lt;image class="icon-positioning" :src="require('./image/icon_positioning.svg').default">&lt;/image> &lt;/view> &lt;/map> // js部分 // 拖动地图 结束 regionchangeEnd(e) { console.log('@@ regionchangeEnd', e) console.log('@@ regionchangeEnd', e.detail) // 小程序 drag 和 scale 的event数据结构不一样，causedBy取值方式不同 const { causedBy: causedByCode, centerLocation } = e.detail; const { causedBy: causedByPhone } = e; if (causedByCode == 'drag' || causedByPhone == 'drag') { console.log('@@ centerLocation', centerLocation); this.dargMap(centerLocation); } else if (causedByCode == 'scale' || causedByPhone == 'scale') { this.scaleMap(); } },]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑之navigationStyle]]></title>
    <url>%2Farchive%2Fmp-fuck.html</url>
    <content type="text"><![CDATA[小程序自定义顶部导航经常会遇到 navigationStyle: &#39;custom&#39; 失效的问题，同时出现了两个顶部导航。遇到这种问题不妨可以尝试一下：重启 微信开发者工具 🙂]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序设置动态分享数据 - Taro]]></title>
    <url>%2Farchive%2Ftaro-mp-share.html</url>
    <content type="text"><![CDATA[前几天遇到一个需求是这样的，一个活动的list，每一个活动都有一个分享按钮，点击分享按钮，将当前活动的详情页分享出去，附带上标题，图片。我第一时间想到的就是，直接获取Current。修改Current.page.onShareAppMessage不就好了么，然后我要开始写bug的时候，脑中灵光一现，发觉事情并没有这么简单。因为小程序onShareAppMeaasge生命周期是在页面初始化时就定义好的，点击button后直接调用，修改完全没有效果。之后我就想到用button的dataset来给onShareAppMessage传参数，结果，button上的data-*属性都被Taro给清除了。淦！最后，通过使用 async/await 实现了这个功能，具体代码如下：parent:&lt;template> &lt;view class="list-container"> &lt;block v-if="list.length"> &lt;product-card :shareData.sync="shareData" class="card-container" v-for="item in list" :key="item.id" :info="item" >&lt;/product-card> &lt;/block> &lt;/view> &lt;/template> &lt;script> import Taro, { Current } from '@tarojs/taro'; export default { data() { return { shareData: {} } } created() { Current.page!.onShareAppMessage = async () => { await new Promise((resolve, reject) => { setTimeout(() => { resolve(this.shareData) }, 0) }) return this.shareData } } } &lt;/script> child:&lt;template> &lt;button @tap="handleShareClick" open-type="share" class="btm-btn" >分享&lt;/button> &lt;/template> &lt;script> export default { name: 'ProductCard' props: { info: Object }, methods: { handleShareClick() { this.$emit('update:shareData', { title: this.info.name, imageUrl: this.info.pic.includes('http') ? this.info.pic : `https:${this.info.pic}`, path: `pages/activity-detail/activity-detail?id=${this.info.activityId}` }) } } } &lt;/script>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>Taro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg + MongoDB搭建server端服务]]></title>
    <url>%2Farchive%2FeggNodeSercer.html</url>
    <content type="text"><![CDATA[Egg 官方文档快速初始化推荐直接使用脚手架，只需几条简单指令，即可快速生成项目（npm &gt;=6.1.0）$ mkdir egg-example && cd egg-example $ npm init egg --type=simple $ npm i 启动项目：$ npm run dev $ open http://localhost:7001 ####]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页自动跟随系统暗模式]]></title>
    <url>%2Farchive%2FperfersColorScheme.html</url>
    <content type="text"><![CDATA[暗模式已经逐渐成为各个软件和网页的新趋势，过去入股偶想要增加暗模式，你可能需要给用户一个选项来开启暗模式。现在大多数主流浏览器都支持了对检验颜色主题的支持，让网页可以自动跟随系统UI模式。介绍下我们今天的主角prefers-color-scheme CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。浏览器兼容性可以去这里查看动手测试一下新建一个简单的html页面test.html&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;title>暗模式&lt;/title> &lt;style> body { background: white; color: black; } &lt;/style> &lt;/head> &lt;body> &lt;h1>测试跟随暗模式&lt;/h1> &lt;p>哈哈哈哈哈啊哈哈哈哈哈哈哈哈哈&lt;/p> &lt;/body> &lt;/html> 接下来在css中加入：@media (prefers-color-scheme: dark) { body { background: black; color: white; } } 切换系统为暗模式。##]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-beautiful-dnd入门教程]]></title>
    <url>%2Farchive%2Freact-beautiful-dnd.html</url>
    <content type="text"><![CDATA[安装npm i react-beautiful-dnd 或yarn add react-beautiful-dnd react-beautiful-dnd结构DragDropContext - 构建一个可以拖拽的范围。onDragStartonDragUpdateonDragEndDroppable - 构建一个可以被拖拽放入的区域块。Draggalbe - 可被拖拽的元素。使用引入react-beautiful-dnd把你想能够拖放的react代码放到DragDropContext中（建议包裹整个应用）DragDropContext不支持嵌套且必须设置DranDropContext的onDragEnd钩子函数(拖拽后的数组重新排序操作在这里进行)import { DragDropContext } from 'react-beautiful-dnd'; class App extends React.Component { onDragStart = () => { /*...*/ }; onDragUpdate = () => { /*...*/ } onDragEnd = () => { // the only one that is required }; render() { return ( &lt;DragDropContext onDragStart={this.onDragStart} onDragUpdate={this.onDragUpdate} onDragEnd={this.onDragEnd} > &lt;div>Hello world&lt;/div> &lt;/DragDropContext> ); } } Dragppable配置import { Droppable } from 'react-beautiful-dnd'; &lt;Droppable droppableId="droppable-1"> {(provided, snapshot) => ( &lt;div ref={provided.innerRef} style={{ backgroundColor: snapshot.isDraggingOver ? 'blue' : 'grey' }} {...provided.droppableProps} > &lt;h2>I am a droppable!&lt;/h2> {provided.placeholder} &lt;/div> )} &lt;/Droppable>; 必需的DroppableId（字符串），用于唯一标识应用程序的droppable。不要更改此ID - 特别是在拖动时。direction:vertical：水平拖拽horizontal：垂直拖拽Droppable的React子元素必须是返回ReactElement的函数。&lt;Droppable droppableId="droppable-1"> {(provided, snapshot) => ({ /*...*/ })} &lt;/Droppable>; 该函数提供了两个参数:provided 和 snapshotprovided.innerRef: 为了使droppable正常工作，必须将provided.innerRef绑定到ReactElement中最高可能的DOM节点。provided.droppableProps: 这是一个Object，它包含需要应用于Droppable元素的属性,包含一个数据属性，可以用它来控制一些不可见的CSSprovided.placeholder: 占位符snapshot： 当前拖动状态，可以用来在被拖动时改变Droppable的外观。&lt;Droppable droppableId="droppable-1"> {(provided, snapshot) => ( &lt;div ref={provided.innerRef} style={{ backgroundColor: snapshot.isDraggingOver ? 'blue' : 'grey' }} {...provided.droppableProps} > I am a droppable! &lt;/div> )} &lt;/Droppable>; Draggableimport { Draggable } from 'react-beautiful-dnd'; &lt;Draggable draggableId="draggable-1" index={0}> {(provided, snapshot) => ( &lt;div ref={provided.innerRef} {...provided.draggableProps} {...provided.dragHandleProps} > &lt;h4>My draggable&lt;/h4> &lt;/div> )} &lt;/Draggable>; Draggable必须始终包含在Droppable中。可以在Droppable内重新排序Draggable或移动到另一个Droppable。DraggablebId（字符串）：必须存在唯一ID，和index（如果为遍历 key也需要）不要更改此ID - 特别是在拖动时。isDragDisabled： 默认false，一个可选标志，用于控制是否允许Draggable拖动。provided.draggableProps 和 provided.dragHandleProps 必须套用至元件其他同Droppable，详情见官方文档数组重新排序onDragEnd = result => { const { source, destination, draggableId } = result; if (!destination) { return; } let arr = Array.from(this.state.todos); const [remove] = arr.splice(source.index, 1); arr.splice(destination.index, 0, remove); this.setState({ todos: arr, }); } demo]]></content>
  </entry>
  <entry>
    <title><![CDATA[模拟实现javaScript new操作符]]></title>
    <url>%2Farchive%2FjavaScript-new-init.html</url>
    <content type="text"><![CDATA[function Person(name){ this.name = name } // function myNew(name){ // var o = {} // o.__proto__ = Person.prototype // Person.call(o,name) // return o // } function myNew(ctor){ if(typeof ctor !== 'function'){ //判断传入参数是否为function类型 throw 'muNew的第一个参数必须为function' } // 创建一个新对象 var o = {} try { o.__proto__ = ctor.prototype //将构造函数的作用域赋给新对象，也就是改变上下文 ，让this指向这个新对象 } catch (error) { Object.setPrototypeOf(o, ctor.prototype) } var result = ctor.apply(o,[].slice.call(arguments,1)) //执行构造函数，传入形参（去掉第一个参数：因为第一个参数为传入的构造函数），获取返回结果 // console.log(123,result) return typeof result === 'object' ? result : o //如果返回值为引用类型， 返回 返回值 否则就返回新创建的对象o // * 所以构造函数的返回值不能为引用类型 （最好不要有返回值） } var a = myNew(Person,"baoza") // var a = new Person("baoza") console.log(a.name) console.log(a instanceof Person)]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>new操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现javaScript call函数]]></title>
    <url>%2Farchive%2FjavaScript-call-init.html</url>
    <content type="text"><![CDATA[function dragon(name){ this.name = name } function say(content){ console.log(this.name + ':' + content) } Function.prototype.myCall = function(params){ params = params || window //多场景适配，当没有传入参数或传入参数为undefined、null的时，指定为window params.fn = this //绑定this，代替上下文执行 let ars = [] //创建空数组保存形参 for(let i = 1; i &lt; arguments.length; i++){ // 从第1位开始循环，将形参存入空数组（第0位是传入的函数实例） ars.push(arguments[i]) } //let ars = Array.prototype.slice(arguments,1) let result = params.fn(...ars) //执行上下文函数，并获取返回结果 delete params.fn //删除上下文函数 return result } var kk = new dragon('CXK') say.myCall(kk,'大家好，我是练习时长两年半的偶像练习生！') var nums = [1,23,435,345,34,45,3,8,25,677,349,563] var maxNum = Math.max.myCall({},...nums) // var maxNum = Math.max.call(Math,...nums) console.log(maxNum)]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包文件]]></title>
    <url>%2Farchive%2Fwebpack-config.html</url>
    <content type="text"><![CDATA[搭建设用于自己的webpack项目工程化打包文件配置，webpack.comfig.js// package.json : npm init -y // 移除main入口，安装包私有 // + "private": true, // - "main": "index.js" const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const {CleanWebpackPlugin} = require('clean-webpack-plugin'); // npm i webpack webpack-cli --save-dev // 全局安装： npm i --global webpack // 最新版本： npm i webpack@beta const webpack = require('webpack'); module.exports = { /* entry: 入口文件，有三种类型 1.字符串： entry: ’./index.js‘ 指定从这个文件路径下面作为打包的入口文件 2.数组： entry: [''./src/'index.js, './vendor/bootstrap.min.js'] 当存在多个入口时，可以使用Array的方式，比如依赖第三方库bootstrap，最终bootstrap会被最佳到打包好的index.js中，数组中的最后一个会被export。 3.对象： entry: { index: './src/index.js', a: './src/a.js' } 设置多个打包目标，每一对键值对都对应一个入口文件（常用于多页面入口文件配置） output: 指生成的文件输出到哪里去。 path： 可能对应文件路径，也可能是从url访问的情况下的路径 filename： 用来配置生成的文件名 */ entry: { app: './src/index.js', // print: './src/print.js' }, plugins: [ // 重置dist文件夹 npm i clean-webpack-plugin --save-dev new CleanWebpackPlugin(), // 热更新 new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin(), // 输出html npm i html-webpack-plugin --save-dev new HtmlWebpackPlugin({ title: 'Output Management' }) ], output: { // filename: 'bundle.js', filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') }, // 报错信息指向源文件 devtool: 'inline-source-map', // 开发环境 devServer: { contentBase: './dist', hot: true }, // build代码压缩 mode: "production", module: { rules: [ // css处理 npm i style-loader css-loader --save-dev { test: /\.css/, use: [ 'style-loader', 'css-loader' ] }, // 图像处理 npm i file-loader --save-dev { test: /\.(png|svg|jpe?g|gif)$/, use: [ 'file-loader', { // 图片处理 压缩 loader: 'image-webpack-loader', options: { mozjpeg: { progressive: true, quality: 65 }, optipng: { enable: false }, pngquant: { quality: '65-90', speed: 4 }, gifsicle: { interlaced: false }, webp: { quality: 75 } } } ] }, // 字体处理 { test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] } ] } }; package.json{ "name": "demo-webpack", "version": "1.0.0", "description": "test", "private": true, "dependencies": { "lodash": "^4.17.15", "npm": "^6.10.2", "webpack": "^4.38.0", "webpack-cli": "^3.3.6" }, "devDependencies": { "clean-webpack-plugin": "^3.0.0", "css-loader": "^3.1.0", "file-loader": "^4.1.0", "html-webpack-plugin": "^3.2.0", "image-webpack-loader": "^5.0.0", "style-loader": "^0.23.1", "webpack-dev-server": "^3.7.2" }, "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack", "start": "webpack-dev-server --open --compress --host 0.0.0.0" }, "author": "", "license": "ISC" }]]></content>
  </entry>
  <entry>
    <title><![CDATA[macOS定时器crontab定时执行python脚本]]></title>
    <url>%2Farchive%2Fcrontab.html</url>
    <content type="text"><![CDATA[查看crontab执行环境查看是否安装python$ which python3 /usr/local/bin/python3 查看crontab是否启动$ sudo launchctl list | grep cron Password: 53570 0 com.vix.cron crontab 服务开启、重启和关闭sudo /usr/sbin/cron start sudo /usr/sbin/cron restart sudo /usr/sbin/cron stop 查看database是否存在$ locate com.vix.cron WARNING: The locate database (/var/db/locate.database) does not exist. To create the database, run the following command: sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist Please be aware that the database can take some time to generate; once the database has been created, this message will no longer appear. 如果报以上错误，则没有database，创建：$ sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist 查看/etc/crontab是否存在$ ll /etc/crontab 不存在则创建：$ sudo touch /etc/crontab crontab命令参数-u user：用来设定某个用户的crontab服务；file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。常用的操作基本就是修改和查看修改：crontab -e查看：crontab -lcrontab文件格式* * * * * commandM H D m d commandM: 分（0-59）H：时（0-23）D：天（1-31）m: 月（1-12）d: 周（0-6） 0为星期日每分钟执行命令：查询当前时间* * * * * date每天9点30执行命令：查询当前时间30 9 * * * date日志重定向不做任何处理日志会保存到/var/mail/Username文件夹下。可以用2&gt;&amp;1来重定向日志保存路径。# 每天9：30执行python脚本，并且将执行日志保存到/Users/admin/Documents/py_bao/ko_data/log/路径下 30 9 * * * /usr/local/bin/python3 /Users/admin/Documents/py_bao/ko_data/ko.py >> "/Users/admin/Documents/py_bao/ko_data/log/$(date +"\%Y-\%m-\%d_\%H").log" 2>&amp;1 执行脚本的时候要将命令的路径写出来usr/local/bin/python3，否则会报错。]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5唤醒APP]]></title>
    <url>%2Farchive%2FH5toApp.html</url>
    <content type="text"><![CDATA[H5 唤醒APP功能最近遇到一个需求，需要在从APP分享出去的H5页面中，带有一个立即打开的按钮，如果本地安装了app，那么就直接唤起本地的app，如果没有安装，则跳转到下载。这是一个很正常的推广和导流量的策略。前端小白从来没有做过这个需求，只能开始哼唧哼唧地开启自己的度娘和谷歌之旅。经过一段时间的探索之旅发现里面的学问很多，要做一个兼容性很好的方案，就需要考虑各种情况，在不同的情况适配不同的方案，比方说用户是在手机浏览器打开还是微信中打开，或者是在pc中打开，universal腾讯应用宝直接打开 APP link是否被关闭等，这就使代码实现变得复杂，且容易出错，且还有安卓平台机型众多、浏览器众多等导致的兼容问题。由于时间有限，这次主要先介绍一个比较普遍的使用URL Scheme进行App跳转的方法。URL Scheme —— 唤端媒介一般来说，我们使用的智能设备上有许多我们的个人信息。比如：联系方式、银行卡/信用卡信息、支付宝/Paypal/各大商城的账户密码、照片甚至行程与位置信息等。如果说，你设备上的每一个应用，不管是官方的还是你从任何商城安装的应用都可以随意地获取这些信息，那么你轻则收到骚扰信息和邮件、重则后果不堪设想。如何让这些信息不被其它应用随意使用，或者说，如何让这些信息仅在设备所有者本人知情并允许的情况下被使用，是所有智能设备与操作系统所要在乎的核心安全问题。针对这个问题，苹果使用了名为「沙盒」的机制：应用只能访问它声明可能访问的资源。一切提交到 App Store 的应用都必须遵守这个机制。在安全方面沙盒是个很好的解决办法，但是有些矫枉过正。敏感的个人信息我们不愿意透露，却不代表所有的信息我们都不想与其它应用共享。因此，我们急需要一个辅助工具来帮助我们实现应用通信， URL Schemes 就是这个工具。URL Schemes是什么[scheme]://[host]/[path]?[query] 我们拿 https://www.baidu.com 来举例，scheme 自然就是 https 了，后面拼接的是传递的参数。URL Schemes 没有特别严格的规范，所以后面参数的具体定义是app开发者去自定义。就像给服务器资源分配一个 URL，以便我们去访问它一样，我们同样也可以给手机APP分配一个特殊格式的 URL，用来访问这个APP或者这个APP中的某个功能(来实现通信)。APP得有一个标识，好让我们可以定位到它，它就是 URL 的 Scheme 部分。但是，两者还有几个重要的区别：所有网页都一定有网址，不管是首页还是子页。但未必所有的应用都有自己的 URL Schemes，更不是每个应用的每个功能都有相应的 URL Schemes。几乎没有所有功能都有对应 URL 的应用。一个 App 是否支持 URL Schemes 要看那个 App 的作者是否在自己的作品里添加了 URL Schemes 相关的代码。一个网址只对应一个网页，但并非每个 URL Schemes 都只对应一款应用。这点是因为苹果没有对 URL Schemes 有不允许重复的硬性要求，所以曾经出现过有 App 使用支付宝的 URL Schemes 拦截支付帐号和密码的事件。一般网页的 URL 比较好预测，而URL Scheme 因为没有统一标准，所以非常难猜，通过猜来获取 应用的 URL Schemes 是不现实的。前面普及了一下URL Schemes的相关知识，作为个前端开发者，就不去深究其中的原理，都交给app开发者吧。接下来开始我们的正题。首先当然是要客户端提供App的Url Schemes。用浏览器去打开scheme在浏览器中打开 scheme 就像打开一个不同的http地址一样。可以在一个 a 标签中打开。&lt;a href="app://" id="open">打开应用&lt;/a> 点击上面的H5页面中的链接将会尝试唤醒对应app，在一些浏览器中，可能会弹出一个提示框，询问用户是否允许打开应用。如果打开的 scheme 在本地没有对应的 app，则点击不会反应。当然还可以使用 JavaScript 代码打开，只需要添加相应的事件触发和处理即可。在JavaScript代码中打开连接有以下几种方式：新建一个隐藏的 iframe ，地址指向需要打开的url使用 window.location 或者 window.location.href 刷新当前页面新建一个隐藏的 a 标签，地址指向打开的url，并触发打开链接事件动态创建一个script脚本，在这个脚本中新建一个a标签并打开// 打开url方式 var urlOpen = { // ios体验差 iframe : url => { var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src = url; document.body.appendChild(iframe); }, location: url => { window.location.href = url; }, href: url => { var a = document.createElement('a'); a.style.display = 'none'; a.href = url; document.body.appendChild(a); a.click(); }, script: url => { var script = document.createElement('script'); script.setAttribute('type','test/javascript'); script.innerHtml = `(function(){ var a = document.createElement("a"); a.style.display = "none"; 'a.href = " + `url.replace(/"/g,'\\"')` + "; document.body.appendChild(a); a.click(); })()`; document.body.appendChild(script); }, open: url => { window.open(url); } } 以上方法是只是解决了在已安装App设备唤醒App的功能，并不能判断是否已安装App，没有安装即跳转至下载链接。浏览器判断是否安装应用在JavaScript中判断页面是否进入后台来判断打开成功。Html5提供了下列事件和属性可以利用：pagehide : 页面隐藏时触发visibilitychange : 页面隐藏没有在当前显示时触发(切换tab也会触发该事件)document.hidden ： 当页面隐藏时，该值为true，显示时为falsevar downloader, scheme = 'app://', // 需要打开的app scheme 地址 iosDownload = 'http://xxx.com', // 如果打开scheme失效的app下载地址 andDownload = 'http://xxx.com'; var u = navigator.userAgent; var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;//android var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);//ios终端 // 给id为openApp的按钮添加点击事件 document.getElementById('openApp').onclick = function (){ window.location.href = scheme; //尝试打开 scheme // 设置定时任务，3秒后打开下载链接 downloader = window.setTimeOut(function(){ if(isAndroid){ window.location.href = andDownload; } if(isIOS){ window.location.href = iosDownload; } },3000); // 如果当前页面隐藏，推断打开 scheme成功，清除定时任务 document.addEventListener('visibilitychange webkitvisibitychange',function(){ if(document.hidden || document.webkitHidden){ clearTimeout(downloader); } }); window.addEventListener('pagehide',function(){ clearTimeout(downloader'); }) } 注意微信中无法唤醒App，需要“用浏览器打开”是因为微信对所有的分享链接接做了scheme屏蔽，也就是说分享连接中所有对于scheme的调用都被微信封掉了。有些app是能在微信打开是因为微信有一个白名单。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css进度条]]></title>
    <url>%2Farchive%2FcssProp.html</url>
    <content type="text"><![CDATA[效果如图：html代码&lt;div class="cell"> &lt;div class="prop">&lt;/div> &lt;/div> css代码.cell{ width: 300px; height: 5px; background: #ddd; position: relative; } .prop{ width: 300px; height: 5px; position: absolute; top:0; left: 0; background: linear-gradient(to right, rgba(239,141,142,1),rgba(98,152,248,1)); transform-origin: left center; transform: scaleX(0); z-index: 9; animation: 2s ease-in 1s slidein infinite; } @keyframes slidein{ 0% { transform: scaleX(0); } 100% { transform: scaleX(1); } } transform-origin: left center; 伸展方向transform: scaleX(0); 横向缩放]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue下监听微信内置浏览器回退事件并关闭当前页面]]></title>
    <url>%2Farchive%2FvueWxBackHistory.html</url>
    <content type="text"><![CDATA[监听浏览器回退事件在Vue mounted周期中监听事件mounted(){ if (window.history &amp;&amp; window.history.pushState) { history.pushState(null, null, document.URL); window.addEventListener('popstate', this.goBack, false); } }, 执行自定义方法（关闭当前页面）index.html中引入微信 JS-SDK。&lt;script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.2.js">&lt;/script> 然后在methods里编辑自定义的goBack方法。methods:{ goBack(){ wx.closeWindow() } } 页面卸载是取消监听事件（防止阻碍其他页面）destroyed(){ window.removeEventListener('popstate', this.goBack, false); },]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背景颜色渐变动画]]></title>
    <url>%2Farchive%2FbackgoundLinearGradient.html</url>
    <content type="text"><![CDATA[实现&lt;h1>背景颜色渐变动画&lt;/h1> body { width: 100wh; height: 100vh; color: #fff; background: linear-gradient(-45deg, #EE7752, #E73C7E, #23A6D5, #23D5AB) no-repeat; background-size: 400%; animation: Gradient 15s ease infinite; } @keyframes Gradient { 0% { background-position: 0% 50% } 50% { background-position: 100% 50% } 100% { background-position: 0% 50% } } h1, h6 { font-family: 'Open Sans'; font-weight: 300; text-align: center; position: absolute; top: 45%; right: 0; left: 0; } 原理background的linear-gradient属性关于linear-gradient可以移步这里上图为background-size为100时，可以看出渐变区域为四个，当我们把background-size改成400，就会在可视区域显示一个渐变区域，然后利用background-position的X坐标定位，改变background的位置，来实现渐变的动画效果。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑（四）之wepy组件]]></title>
    <url>%2Farchive%2FTencentMP-4.html</url>
    <content type="text"><![CDATA[写组件navBar.wepy&lt;template> &lt;view class="navBar {{iphoneX ? 'iphoneX-tabBar' :''}}"> &lt;view class="navBar-bg">&lt;/view> &lt;view class="navBar-content" wx:if="{{!showExam}}"> &lt;view class="navBar-title">{{tabBarTitle}}&lt;/view> &lt;image wx:if="{{returnIcon}}" class="icon-left" src="https://16bit.sunlands.com/p/static/ko-mp/left-icon.png" @tap="navigateBack" /> &lt;/view> &lt;/view> &lt;/template> &lt;script> import wepy from 'wepy' export default class NavBar extends wepy.component { data = { iphoneX: wx.getStorageSync('iphoneXStatus') } props = { showExam: Boolean, returnIcon: { type: Boolean, twoWay: true }, tabBarTitle: String, } methods = { navigateBack() { wx.navigateBack({ delta: 1 }) } } } &lt;/script> less&lt;style lang="less"> .navBar{ position: relative; padding-top: 40rpx; width: 100vw; height: 88rpx; .navBar-bg{ width: 100%; height: 100%; } .navBar-content{ position: fixed; top: 0; left: 0; z-index: 100; width: 100vw; height: 88rpx; padding-top: 40rpx; background: #FFFFFF; .navBar-title{ width: 100vw; height: 88rpx; text-align: center; line-height: 88rpx; font-size: 32rpx; font-weight: 700; color: #000000; } .icon-left{ position: absolute; left: 14rpx; bottom: 11rpx; width: 34rpx; height: 34rpx; padding: 16rpx; } } .iphoneX-tabBar{ padding-top: 88rpx; .navBar-content{ padding-top: 88rpx; } } &lt;/style> 引入组件index.wepyimport wepy from 'wepy' import NavBar from '../components/navBar'; export default class Index extends wepy.page { components = { 'nav-bar': NavBar } } 使用组件 &lt;nav-bar :returnIcon.sync='returnIcon' :tabBarTitle.sync="tabBarTitle">&lt;/nav-bar> 注意：在使用组件中，组件上传值要与组件内定义的类型一致，:returnIcon.sync=&#39;returnIcon&#39;，returnIcon为Boolean类型；且不支持:returnIcon.sync=&#39;!returnIcon&#39;，!符号。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>wepy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python判断本地是否存在当前文件&&保存为本地json文件]]></title>
    <url>%2Farchive%2Fpython-os-json.html</url>
    <content type="text"><![CDATA[判断本地是否存在当前文件根据python-os包来判断当前文件路径是否有文件。import os res_path = 'data.json' data= [] i=0 while i&lt; range(10): data.append({'a':'哈哈','b':2,'c':3}) i+=1 if (os.path.exists(res_path)): print('文件已存在！') return # 格式化数据，保存在json文件中 with open(res_path,'w') as dump_f: json.dump(data,dump_f) 第一次执行的时候会在本地看到data.json文件，第二次执行的时候就会提示文件已经存在了，这个例子中就算不判断本地存不存在data.json都没有关系，因为open(res_path,&#39;w&#39;)中的w的意思就是，打开本地文件，没有这个文件就创建这个文件，有就清空这个文件再打开，更多参数：w 以写方式打开，a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ )python-os包的其他使用：os.path.abspath(path) #返回绝对路径os.path.basename(path) #返回文件名os.path.commonprefix(list) #返回多个路径中，所有path共有的最长的路径。os.path.dirname(path) #返回文件路径os.path.exists(path) #路径存在则返回True,路径损坏返回Falseos.path.lexists #路径存在则返回True,路径损坏也返回Trueos.path.expanduser(path) #把path中包含的”~”和”~user”转换成用户目录os.path.expandvars(path) #根据环境变量的值替换path中包含的”$name”和”${name}”os.path.getatime(path) #返回最后一次进入此path的时间。os.path.getmtime(path) #返回在此path下最后一次修改的时间。os.path.getctime(path) #返回path的大小os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误os.path.isabs(path) #判断是否为绝对路径os.path.isfile(path) #判断路径是否为文件os.path.isdir(path) #判断路径是否为目录os.path.islink(path) #判断路径是否为链接os.path.ismount(path) #判断路径是否为挂载点（）os.path.join(path1[, path2[, …]]) #把目录和文件名合成一个路径os.path.normcase(path) #转换path的大小写和斜杠os.path.normpath(path) #规范path字符串形式os.path.realpath(path) #返回path的真实路径os.path.relpath(path[, start]) #从start开始计算相对路径os.path.samefile(path1, path2) #判断目录或文件是否相同os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件os.path.split(path) #把路径分割成dirname和basename，返回一个元组os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组os.path.splitunc(path) #把路径分割为加载点与文件os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数os.path.supports_unicode_filenames #设置是否支持unicode路径名遍历当前文件夹下文件rootdir = 'F:\data' list = os.listdir(rootdir) #列出文件夹下所有的目录与文件 for i in range(0,len(list)): path = os.path.join(rootdir,list[i]) if os.path.isfile(path): #你想对文件的操作]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python-os</tag>
        <tag>python-json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3+连接mysql8+数据库]]></title>
    <url>%2Farchive%2Fpython-mysql.html</url>
    <content type="text"><![CDATA[在使用mysql官方的python插件mysql-connector时发现突然报了个错误： mysql.connector.errors.NotSupportedError: Authentication plugin 'caching_sha2_password' is not supported 后来才知道，MySQL8和低版本不兼容，解决办法有两种：把mysql8降级成低版本；把认证的选项设置为“Use Legacy Authentication Method”然而我就比较厉害了，我这两个都没有，我选择使用pymysql，python3 -m pip install PyMySQL 连接mysqlimport pymysql # 打开数据库连接 db = pymysql.connect(host="localhost",user="root",password="123456",db="test",port=3306,charset='utf8') # 或者简写为： db = pymysql.connect("localhost","root","Aa123456","test") 执行sql语句插入单条数据# 使用 cursor() 方法创建一个游标对象 cursor cursor = db.cursor() def insertSql(hot_song_name,hot_song_id): str_url = "https://www.baidu.com" try: cursor.execute('insert into hot_songs(song_name,song_netease_id,song_url) values(%s,%s,%s)',(hot_song_name,hot_song_id,str_url)) # 数据变化要提交sql语句 db.commit() except: # 操作回退 db.rollback() return print(cursor.rowcount, "{}：添加数据库成功。".format(hot_song_name)) 插入多条数据sql = 'insert into hot_songs (song_name,song_netease_id,song_url) values(%s,%s,%s)' val = [(hot_song_name,hot_song_id,str_url),(hot_song_name,hot_song_id,str_url),(hot_song_name,hot_song_id,str_url)] cursor.execute(sql,val) 关闭数据库# 关闭数据库连接 cursor.close() db.close() 判断插入的数据在当前数据库中是否存在我当前使用的方法是，给其中的非主键song_id列设置unique属性，利用插入相同song_id报错回退来避免插入重复数据。给列增加unique属性：alter table hot_songs add unique(song_netease_id);]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【git】给本地代码添加多个远程git仓库]]></title>
    <url>%2Farchive%2Fgit-remote.html</url>
    <content type="text"><![CDATA[git remote add other https://xxxxxxxxx.gitcd到目标项目目录，先git remote -v查看当前仓库有哪些远程仓库，然后使用git remote add other https://xxxxxxxxx,然后再git remote -v查看一下，就可以看到远程仓库地址多可一个叫other的仓库。第一种方法想要push到多个仓库的时候，要执行两次push命令：git push -u origin mastergit push -u other mastergit remote rm other 删除other远程仓库地址git remote set-url –add other https://xxxxxxxxxx.git第二种方法使用git remote set-url --add other https://xxxxxxxxxx.git，在当前本地连接的远程仓库下新增仓库地址。只需要执行一次push就可以同时上传到两个仓库中。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git remote</tag>
        <tag>添加多个远程git仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐爬虫]]></title>
    <url>%2Farchive%2Fpython-netease-crawler.html</url>
    <content type="text"><![CDATA[文明、富强、民主。。。分析网易云音乐html DOM结构想要爬取网易云歌单中的音乐，首先要知道我们需要拿到些什么，歌单id、歌曲id、接口地址这三个是必须的。接下来是具体的获取这些数据的操作流程：打开网易云音乐首页，打开network。随便点击一个歌单，找到https://music.163.com/playlist?id=请求。如图：拿到歌单id，即这个请求id=后面的数字点开这个请求，在Preview查看请求返回的html源码，找到歌单中歌曲的名字，复制一个歌曲名。再在Response中，使用快捷键command+F查找（windows为control+F），粘贴刚才复制的歌曲名字，回车。可以看到，歌曲名在一个ul&gt;li&gt;a标签中，并且在a标签的href中还带有这首歌的ID，完美。在音乐页面，点击一首歌播放，查看获取歌曲播放地址的接口。很明显看到这个接口返回了歌曲的地址。接下来就是来解析一下这个接口传递的参数了，这是最麻烦的一步了，有想了解的可以去自行百度了解一下，知乎中的大佬已经有人破解出来了。我这里就直接用我已经获得到的网易云Api了。# 获取播放地址(get请求): http://music.163.com/song/media/outer/url?id=561042302.mp3 编写python爬虫废话不多说，直接贴出源码，各个位置标注都已经做好#!/usr/bin/env python3 # -*- coding: utf-8 -*- import re import urllib.request import urllib.error import urllib.parse import json import threading from time import sleep import os json_path = 'data.json' def get_all_hotSong(): #获取歌单所有歌曲名称和id # url='http://music.163.com/discover/toplist?id=3778678' #网易云云音乐热歌榜url url='https://music.163.com/playlist?id=3778678' #播放列表url z/mpi 2476005642 like 536254974 header={ #请求头部 'User-Agent':'Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36' } request=urllib.request.Request(url=url, headers=header) html=urllib.request.urlopen(request).read().decode('utf8') #打开url html=str(html) #转换成str pat1=r'&lt;ul class="f-hide">&lt;li>&lt;a href="/song\?id=\d*?">.*&lt;/a>&lt;/li>&lt;/ul>' #进行第一次筛选的正则表达式 result=re.compile(pat1).findall(html) #用正则表达式进行筛选 result=result[0] #获取tuple的第一个元素 pat2=r'&lt;li>&lt;a href="/song\?id=\d*?">(.*?)&lt;/a>&lt;/li>' #进行歌名筛选的正则表达式 pat3=r'&lt;li>&lt;a href="/song\?id=(\d*?)">.*?&lt;/a>&lt;/li>' #进行歌ID筛选的正则表达式 hot_song_name=re.compile(pat2).findall(result) #获取所有歌单的歌曲名称 hot_song_id=re.compile(pat3).findall(result) #获取所有歌单歌曲对应的Id return hot_song_name,hot_song_id def download_song(hot_song_name,hot_song_id): singer_url = 'http://music.163.com/song/media/outer/url?id={}.mp3'.format(hot_song_id) res_path = '/Users/admin/Documents/songs/{}.mp3'.format(hot_song_name) if (os.path.exists(res_path)): print('{}---已存在！'.format(hot_song_name)) return print('歌曲：{}'.format(hot_song_name),'ID:{}'.format(hot_song_id),'正在下载...') urllib.request.urlretrieve(singer_url,f_path) # 保存到本地目录 print('{}---下载完成'.format(hot_song_name)) song_item = {'name':hot_song_name,'id':hot_song_id,'url':'http://music.163.com/song/media/outer/url?id={}.mp3'.format(hot_song_id)} songs.append(song_item) sleep(1) hot_song_name,hot_song_id=get_all_hotSong() #获取歌单所有歌曲名称和id songs=[] threads = [] files = range(len(hot_song_name)) num=0 while num &lt; len(hot_song_name): #下载歌单中的所有歌 t = threading.Thread(target=download_song,args=(hot_song_name[num],hot_song_id[num])) threads.append(t) num+=1 runFiles = []; for i in files: runFiles.append(i) if(len(runFiles)>=10): for i in runFiles: threads[i].start() for i in runFiles: threads[i].join() runFiles=[] if(len(runFiles)!=0): for i in runFiles: threads[i].start() for i in runFiles: threads[i].join() # 格式化数据，保存在json文件中 with open(json_path,'w') as dump_f: json.dump(songs,dump_f) print('执行完毕') 踩坑爬取的时候都很正常，但是当我打开data.json的时候我就惊呆了，中文居然全都变成了unicode码。在我耗费了一天一夜查找了各种资料之后，终于知道了原因，python在写入本地文件的时候，默认转码为ascII编码，所以，将下面这句话改成这样就OK了。# 格式化数据，保存在json文件中 with open(json_path,'w') as dump_f: # json.dump(songs,dump_f) + json.dump(songs,dump_f,ensure_ascii=False) 源码地址：这里,觉得还不错的话记得给个star哦，]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下privoxy配置，让终端实现翻墙]]></title>
    <url>%2Farchive%2FmacPrivoxy.html</url>
    <content type="text"><![CDATA[作为开发者，肯定会经常使用 npm、wget/curl、git、brew和docker等工具下载或安装，然而往往会出现超慢 timeout 卡死的情况，也是让我们怨气颇深。所以，为了解决这个问题，伟大的privoxy出现了！接下来给大家介绍下如何使用privoxy来让我们的终端连接外网。下载Shadowscoks可以去我的百度云下载最新版SS。密码:ln28下载&amp;&amp;安装成功后，配置自己的服务器设置。安装 &amp;&amp; 配置privoxy使用homebrew安装privoxybrew install privoxy 安装成功后，终端输入cd /usr/local/etc/privoxy/进入privoxy配置文件夹下，运行：echo 'listen-address 0.0.0.0:8118\nforward-socks5 / localhost:1087 .' >> config ps: 注意别忘了最后的.！启动privoxy执行：sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config 或sudo /usr/local/Cellar/privoxy/3.0.26/sbin/privoxy /usr/local/etc/privoxy/config 或sudo /Applications/Privoxy/startPrivoxy.sh ps：由于privoxy的版本可能会不同，所以privoxy可能会存在不同的路径里，以上三个是大部分路径，一切按实际电脑上的正确路径为准启动监听端口export http_proxy=http://127.0.0.1:1087; export https_proxy=https://127.0.0.1:1087; 查看8118端口有没有监听成功netstat -na | grep 8118 如果出现以下代码，则表示监听成功，tcp4 0 0 127.0.0.1.8118 *.* LISTEN 测试是否翻墙成功curl测试终端输入curl www.google.com，如果返回谷歌首页的html代码，说明成功访问到谷歌。这就说明你已经翻过墙头，连接外网了！！！wget测试ps: wget需输入brew install wget安装终端输入wget https://www.google.com，结果如下图所示，也同样说明你已经翻过墙头，连接外网了！！！]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>privoxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摔爹神曲！！！期待ing]]></title>
    <url>%2Farchive%2Fmusic_shuaidie.html</url>
    <content type="text"><![CDATA[在进击的巨人第三季第七集中的插曲，简直直击灵魂，期待ost !!!!!!这一集中女王帅炸！疯狂打电话！!function(){var e=new DPlayer({container:document.getElementById("dplayer0"),autoplay:!0,theme:"#FADFA3",loop:!0,video:{url:"http://ph1dk41nw.bkt.clouddn.com/video/shuaidieshenqu.mp4"}});window.dplayers||(window.dplayers=[]),window.dplayers.push(e)}()]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>进击的巨人</tag>
        <tag>摔爹神曲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个服务器脚本]]></title>
    <url>%2Farchive%2Fshell_script.html</url>
    <content type="text"><![CDATA[最近由于业务需求，要查询保存在服务器日志里的小程序数据，每周要查七天的数据，每天还另有四种渠道。每种渠道还有三种情况，每种情况又要分PV和UV。重复的工作太多太多，所以在手写了几天之后，我终于受不了了！我决定写个脚本来摆脱这残酷的机械工作。不得不说，懒惰真的可以使人进步。😂由于本人对Unix的了解很局限，只会一些常用的命令，所以在动手之前先看了一遍这两篇教程：什么是shell脚本编写第一个shell脚本首先了解UNIX的基础文件管理1.文件类型普通文件: 一个普通的文件是系统上包含数据、 文本或程序指令的文件。在本教程中，你将使用普通文件。目录: 目录存储特殊和普通文件。 UNIX 目录对于熟悉 Windows 或者 Mac OS 的用户，相当于文件夹。特殊文件: 一些特殊的文件提供访问硬件，例如硬盘、 CD - ROM 驱动器、 调制解调器和以太网适配器。其他特殊文件类似于别名或快捷方式，使您能够访问单个文件使用不同的名称。2.常用命令ls:为了列出存储在当前目录中的文件和目录。ls -l:获得有关列出的文件的详细信息。ls -a:列出不可见文件。vi filename:有这个文件就编辑，没有则新建 (filename表示文件名)。cat filename:查看文件的内容。wc filename:获取一个文件中的总的行数，字数和字符数。cp filename copyfile:复制文件 你会发现多了一个文件 copyfile 在您的当前目录。此文件与原始文件 filename 完全相同。mv filename newfile:重命名 将现有文件完全移动到新的文件。所以在这种情况下你只能发现 newfile 在你当前的目录中。rm filename:删除现有文件文件权限1.权限表示符当使用 ls -l 命令的时候，会将与文件相关的各种权限展示出来，如下：$ls -l /home/amrood -rwxr-xr-- 1 amrood users 1024 Nov 2 00:10 myfile drwxr-xr--- 1 amrood users 1024 Nov 2 00:10 mydir 输出的第一列表示的是与文件或者目录相关的访问模式或者权限。权限被分为三组，组中的每个位置代表一个特定的权限，这个顺序是：读(r)、写(w)和执行(x):前三个字符 (2-4) 表示文件的所有者的权限。例如 -rwxr-xr– 代表，文件的所有者拥有读 (r)、写 (w) 和执行 (x) 的权限。第二组的三个字符 (5-7) 包含了该文件所属组的权限。例如 -rwxr-xr– 表示了所属组拥有读 (r) 和执行 (x) 的权限，但没有写权限。最后一组三个字符 (8-10) 代表其他人的权限。例如 -rwxr-xr– 代表其他人只有读 (r) 的权限。2.改变权限改变文件或目录的权限，可以使用 chmod(change mode)命令。有两种方法可以使用 chmod：符号模式和绝对模式。符号模式对于初学者来说使用符号模式是最简单的来修改文件或目录的权限方法。可以用下表中的符号来添加、删除或指定你想要设置的权限。Chmod 操作符描述+给文件或者目录添加指定的权限。-删除文件或者目录的权限。=设置指定的权限。绝对权限用chmod命令修改权限的第二种方法，是使用一个数字来指定文件的一些列权限。每个权限被分配了一个数值，如下表所示， 并且给每个权限集的总和提供了一个数值。数值权限八进制表示参照0没有权限- - -1可执行的权限- -x2写权限-w-3执行和写权限: 1 (执行) + 2 (写) = 3-wx4读取权限r- -5读取和执行权限: 4 (读取) + 1 (执行) = 5r-x6读取和写权限: 4 (读) + 2 (写) = 6rw-7所有权限: 4 (读) + 2 (写) + 1 (执行) = 7rwx变量变量类型局部变量：该类型变量只会在当前 Shell 实例内有效。他们无法适用于由 Shell 启动的程序。他们仅在命令提示符处进行设置。环境变量：环境变量对 Shell 的任何子进程都有效。部分程序是需要正确的调用函数才需要环境变量。通常，Shell 脚本只会定义程序运行需要的环境变量。Shell 变量：该类型变量是由 Shell 设置的专用变量，是用来正确调用函数用的。有时这些变量是环境变量，有时是局部变量。1.定义变量：variable_name=variable_value 2.访问变量#!/bin/sh NAME="Zara Ali" echo $NAME 3.删除变量unset variable_name 数组定义数组NAME01="Zara" NAME02="Qadir" NAME03="Mahnaz" NAME04="Ayan" NAME05="Daisy" array_name=(value1 ... valuen) 访问数组 #!/bin/sh NAME[0]="Zara" NAME[1]="Qadir" NAME[2]="Mahnaz" NAME[3]="Ayan" NAME[4]="Daisy" echo "First Index: ${NAME[0]}" echo "Second Index: ${NAME[1]}" 可以使用以下方法之一，来访问数组中的所有项目： ${array_name[*]} ${array_name[@]} 循环循环是一个强大的编程工具，可以使您能够重复执行一系列命令。针对 Shell 程序员，有 4 种循环类型：while 循环for 循环until 循环select 循环#!/bin/sh a=0 while [ "$a" -lt 10 ]# this is loop1 do b="$a" while [ "$b" -ge 0 ] # this is loop2 do echo -n "$b " b=`expr $b - 1` done echo a=`expr $a + 1` done #!/bin/sh for i in A B C D; do echo $i done 最后终于在折腾了这么长时间之后写下了我的第一次脚本]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑（三）各种跳转的区别]]></title>
    <url>%2Farchive%2FTencentMP_3.html</url>
    <content type="text"><![CDATA[小程序中一共有五种跳转方法，wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab、wx.navigateBack，它们都有什么区别呢，怎么确定什么时候该用哪个呢。wx.navigateTowx.redirectTox.reLaunchwx.switchTabwx.navigateBack页面栈区分这五种跳转之前，要先了解下小程序的页面栈。通过getCurrentPages()方法可以获取到当前的页面栈，我们先来console一下看看这是个什么东西console.log(getCurrentPages())可以看到打印出来是一个数组，数组中有两个page的实例。证明我现在所在的页面是在第二级，打开这个实例就可以看到该页面的data和function。⚠️ 注意：小程序的页面栈最多为5层！wx.navigateTo用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面。对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用。wx.redirectTo当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 5 层页面栈。这时，我们应该考虑选择 wx.redirectTo。wx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面。这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间wx.reLaunchwx.reLaunch()与 wx.redirectTo()的用途基本相同， 只是 wx.reLaunch()先关闭了内存中所有保留的页面，再跳转到目标页面。wx.switchTab对于跳转到tabBar的页面，最好选择是wx.switchTab()，它会先关闭所有非tabBar的页面。其次，也可以选择 wx.reLaunch()，它也能实现从非tabBar跳转到tabBar，或在tabBar间跳转，效果等同wx.switchTab()。使用其他跳转 API 来跳转到tabBar，则会跳转失败。值得注意的是：当用wx.redirectTo和wx.reLaunch从某个页面跳转到另一个页面时，小程序的左上角是不会出小返回按钮的。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑之旅（二）request:fail错误]]></title>
    <url>%2Farchive%2FTencentMP_2.html</url>
    <content type="text"><![CDATA[在开发小程序的过程中有些人会遇到这样的问题，在开发者工具中可以正常请求接口获得数据，但是在手机预览和上线之后就会请求失败。怎么回事呢？报错信息：request:fail ssl hand shake error或者：此服务器的证书无效。一下列出可能这一情况的原因：。后台域名没有配置域名不支持https没有重启工具域名没有备案，或是备案后不足24小时；备案未生效ssl协议有问题Geotrust先检查下你的站点。把一些常规的问题解决掉，比如中级证书没装，等等问题。微信支持，且只支持ssl_protocols TLSv1.2及以上版本;所以，你需要把SSL V2，SSL V3这些协议都删掉加密方式ssl_ciphers AES128+EECDH:AES128+EDH:!aNULL小程序需要TLS 版本支持1.2及以下版本： windows系统至少要2008R2以上，才能支持1.0、1.1、1.2 少一个版本不支持都不行。所以03系统想折腾小程序的朋友，自己装R2以上或用linux系统免费的证书可以到阿里云，腾讯云。ps:给大家提个醒 startcom 下面的dv ssl 证书， 亲测 在ios10 小程序中无法请求成功 在ios9 下可以请求成功，然后换成鹅厂的免费证书，全部都没有问题了。这不是广告 折腾了两天发现ios10 可能已经对startcom 有处罚了证书问题测试是否为证书问题：同时测试ios和安卓，假如有一方可以，一方不行，则是证书问题，请选用受认可的证书检测地址：https://www.qcloud.com/product/ssl.html#userDefined10证书受信任的问题，部分国内签发的SSL证书，在Android上不受信任，推荐GeoTrust；如果页面有动静分离，静态资源使用独立域名的话，也需要为该域名申请证书；android低版本不支持SNI扩展，受此限制，一台服务器只能部署一个数字证书；配置中间证书参考 http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4897报错 request:fail ssl hand shake error可以请求数据，真机预览无法请求服务器数据配置ssl时内容填写不完善少了一份证书，配置的证书不是小程序https地址的证书，然后配置了一个中级证书tls需要支持1.0 1.1. 1.2版本wx.request 请求参数method的value要大写(例如:GET)。下载最新的微信客户端检查手机系统时间是否为当前日期，系统时间与当前时间相差过长，会导致证书过期，调整到当前日期即可。ps:如果用的是腾讯云提供的免费证书。腾讯云下载证书zip文件，解压后务必使用nginx目录中的root crt 和 key两个文件。ssl检测地址：https://www.myssl.cn/tools/check-server-cert.htmlhttps端口使用8443时无法访问，需改成443本人也是遇到了ssl证书问题，然后查阅了一下资料解决了。如果有什么新的问题或者想了解详细的解决方案及案例，可以移步到这位大佬的博客]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序踩坑</tag>
        <tag>小程序request:fail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装软件时提示文件已损坏]]></title>
    <url>%2Farchive%2FMacInstallProblem.html</url>
    <content type="text"><![CDATA[出现这种情况的原因是因为苹果的新系统（macOS Sierra 10.12.X）加强了安全机制，默认不允许用户安装非app store下载的应用程序。所以只要设置成允许运行任何来源的应用后就可以解决了，具体方法如下：一 查看是否打开允许运行任何来源下载的应用首先查看系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用中是否有任何来源选项。如图：如果有，且处于没有选中状态。点击左下角小锁头，输入电脑密码，然后勾选上任何来源后重新安装尝试。如果没有任何来源这个选项，继续向下看。终端修改安全机制打开终端 -&gt; 输入sudo spctl --master-disable-&gt; 回车 -&gt; 输入密码 -&gt; 回车 -&gt; 重新安装sudo spctl –master-disable ：显示任何来源选项sudo spctl –master-enable ：不显示任何来源选项]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>文件损坏</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cloud+腾讯云主机实现在线开发]]></title>
    <url>%2Farchive%2FTencentCloud.html</url>
    <content type="text"><![CDATA[首先做好准备工作，需要用到以下工具：1. coding2. cloud Studio3. 腾讯云主机注册使用coding直接去官网注册，这里不做过多的bb，接下来是重点：注册好了之后，点击左上角的cloud studio按钮注册好了之后会赠送你一个月的免费cloud studio专用云主机，之后就要自己续费使用了。使用cloud Studio绑定好腾讯云之后，你就会看到这个页面了，看到这个页面就说明你已经成功创建了自己的云主机，并且可以在这里进行各种你想进行的操作了。这里是文件树区域这里是编辑区这里是终端命令行工具这里可以创建外部访问链接注：创建外部访问链接时，必须在命令行中设置要监听访问的端口。以 PHP 环境为例，在终端输入php -S 0.0.0.0:8080即可监听 8080 端口。设置好你终端中监听的端口，然后点击创建就OK了。]]></content>
      <categories>
        <category>猎奇</category>
      </categories>
      <tags>
        <tag>cloud</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑之旅（一）]]></title>
    <url>%2Farchive%2FTencentMP_1.html</url>
    <content type="text"><![CDATA[本人作为刚刚踏入小程序开发不久的新人来说，每天都要被它折磨的欲仙欲死，各种用的不习惯，没办法，也只能选择接受了。其实对于用过Vue的人来说，可以选择小程序的wepy框架，wepy框架的写法习惯之类的和Vue大致上都很类似，在我感觉就是把小程序和Vue强行拧巴到了一起。（强行吐槽一下😂😂）声明提前：以下仅是本菜鸟在开发中遇到的问题和解决方法，如有不正确的地方希望大佬们可以提出让我修改，以免误导了别人。如果要做好小程序，就一定要了解小程序的运行流程，简略流程图如下:(ps:画个图都是爱你的形状❤)小程序前台、后台、销毁初次进入小程序的运行流程：app.onLaunch -&gt; app.onShow -&gt; page.onLoad -&gt; page.onShow -&gt; page.onReady当用户点击小程序右上角的关闭按钮时，小程序从前台进入后台 ；此时小程序执行app.onHide -&gt; page.onHide当用户在几分钟内再次点击该小程序时，小程序从后台进入前台；此时小程序执行app.onShow -&gt; page.onShow小程序从后台进入前台时。不会携带任何参数。即options.query是空的。生命周期 - apponLaunch：监听小程序初始化当小程序初始化完成时触发，且全局仅触发一次。意思就是从用户打开小程序，到小程序被销毁，这个生命周期函数只会在进入小程序且初始化完成时触发。onShow：监听小程序显示当小程序启动，或从后台进入前台显示，会触发 onShow。意思就是说，当用户点击右上角关闭按钮，并且在几分钟内再次进入该小程序，或者从当前页面返回到上一级页面时，会触发onShow。onHide：监听小程序隐藏当小程序从前台进入后台，会触发 onHide。意思就是说，当用户点击右上角关闭按钮或者保留当前页面跳转到其他页面时(wx.navigateTo)，会触发onHide。onError：错误监听函数当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息app实例app.js 中的globalData数据和function都是全局的。调用方式：在Page中通过getApp()方法得到App对象并获得全局的数据和调用全局的函数页面生命周期 - pagepage()函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。onLoad: 页面加载一个页面从初始化到被销毁只会调用一次。接收页面参数 可以获取wx.navigateTo和wx.redirectTo及中的 query。onShow: 页面显示每次从后台进入前台都会调用一次。onReady: 页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide: 页面隐藏每次从前台进入后台时调用。ex:当navigateTo或底部tab切换时调用。onUnload: 页面卸载当页面被销毁时，即redirectTo或navigateBack的时候调用。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学python（一）]]></title>
    <url>%2Farchive%2FpythonOne.html</url>
    <content type="text"><![CDATA[python简介是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。主要应用于：网络应用，包括网站、后台服务等等，其次是一些脚本任务。解释型语言，运行速度慢于C本系列下所有运行环境都是基于mac环境安装python可以去python官网下载。然后一路按照提示next下去就好了。安装好了之后打开终端输入python，如果看到如图内容，就说明安装成功了。输出和输入「Hello World」输出：print()>>> print('hello world') hello world 输入：input()>>> name = input('input:') input:'Baomer' >>> name 'Baomer' 在你输入name = input()并回车之后，终端就已经在等待你输入，输入完成好再会车，内容就会保存在变量name中。input()与raw_input()print()函数接受一个标准输入数据（即python表达式），返回string类型。raw_input()函数将所有输入均看作字符串，返回string类型。>>> name = input('input:') input:123 >>> type(name) &lt;type 'int'> >>> name = input('input:') input:'Baomer' >>> type(name) &lt;type 'str'> >>> name = input('input:') input:Baomer Traceback (most recent call last): File "&lt;stdin>", line 1, in &lt;module> File "&lt;string>", line 1, in &lt;module> NameError: name 'Baomer' is not defined >>> name = raw_input('input:') input:123.2 >>> name '123.2' >>> type(name) &lt;type 'str'> >>> name = raw_input('input:') input:Baomer >>> name 'Baomer' 数据类型整数正整数负整数与数学中的写法一致。1，2，-12，0等等。十六进制用0x前缀和0-9，a-f表示。浮点数浮点数即小数，可以用数学写法，但是如果是特别小或者特比大的小数，就必须用科学技术法来表示。ex：1.23x109就是1.23e9，或者12.3e8；0.000012可以写成1.2e-5字符串字符串是以单引号&#39;或双引号&quot;括起来的任意文本。如果字符串本身有单引号或者双引号，可以用转义字符来标识。如果字符串里面有很多字符都需要转义，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义。如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写）布尔值可以用and、or和not运算(即与、或、非)。空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。类似于javascript中的null变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。常量python中习惯用全大写的变量名来表示常量，比如PI。但是python中并没有任何机制保证PI不会被改变。python中的除法Python中分为3种除法：传统除法、精确除法、地板除。传统除法如果除数和被除数都是整数，则执行地板除。如果有一个数为浮点数或都为浮点数，则执行精确除法。>>>1/2 0 >>>1/2.0 0.5 精确除法执行from __future__ import division指令，不管操作数是整形还是浮点型。都会执行精确除法。>>>from __future__ import division >>>1/2 0.5 >>>1.0/2.0 0.5 地板除从Python2.2开始，增加了一个操作符 // ，来执行地板除。即不管操作数为何种数值类型，总是会舍去小数部分，返回数字序列中比真正的商小的最接近的数字。>>>1//2 0 >>>1.0//2 0 >>>-1//2.0 -1]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间通讯]]></title>
    <url>%2Farchive%2FvueCommunication.html</url>
    <content type="text"><![CDATA[vue作为组件化框架，组件之间的通讯是日常开发中必不可少的；通讯类型有三种：父组件-&gt;子组件子组件-&gt;父组件同级组件之间父组件 -&gt; 子组件废话不多说，直接上代码。&lt;template> &lt;div id='fatherComponent'> &lt;children-component :params='params' >&lt;/children-component> &lt;/div> &lt;/template> &lt;script> import childrenComponent from './childrenComponent.vue' //子组件的相对路径 export default { data(){ return { params:{ a:1, b:2, c:3 }, } }, . . . components:{ 'children-component':childrenComponent } } &lt;/script> 父组件中的写法大致就是这样， 需要注意的是：:params=&#39;params&#39;在组件上绑定要传给组件的值，可以是数组，字符串，布尔，对象等等类型的值。import childrenComponent from &#39;./childrenComponent.vue&#39;引入子组件&#39;children-component&#39;:childrenComponent 在components生命周期中声明子组件标签（驼峰命名转化为-代替）。&lt;template> &lt;div id='childrenComponent'> &lt;p>我是{{params.a}}&lt;/p> &lt;/div> &lt;/template> &lt;script> export default { props:['params'], data(){ }, mounted(){ console.log(this.params) } } &lt;/script> 子组件中需要注意的是：props:[&#39;params&#39;] 在子组件中要用props来接受父组件传来的值。并且要与父组件绑定的变量名一致。&lt;p&gt;我是&lt;/p&gt; 在DOM中可以直接用这个变量来取值。子组件 -&gt; 父组件&lt;template> &lt;div id='fatherComponent'> &lt;children-component :params='params' @getChildrenData='childrenData' >&lt;/children-component> &lt;/div> &lt;/template> &lt;script> import childrenComponent from './childrenComponent.vue' //子组件的相对路径 export default { data(){ return { params:{ a:1, b:2, c:3 }, } }, methods:{ childrenData(_val){ console.log(_val) } }, . . . components:{ 'children-component':childrenComponent } } &lt;/script> @getChildrenData=&#39;childrenData&#39; 声明一个函数（getChildrenData）来监听子组件emit来的getChildrenData函数。&lt;template> &lt;div id='childrenComponent'> &lt;p>我是{{params.a}}&lt;/p> &lt;button @click='toFather'>&lt;/button> &lt;/div> &lt;/template> &lt;script> export default { props:['params'], data(){ msg:'我收到啦！' }, mounted(){ console.log(this.params) }, methods:{ toFather(){ this.$emit('getChildrenData',this.msg) } } } &lt;/script> this.$emit(&#39;getChildrenData&#39;,this.msg) 子组件使用$emit函数会向父组件以参数的形式来传递数据。同级组件之间通讯之间在我的理解来看，既然是同级组件，那必然有一个相同的父组件，所以也是可以用emit函数来通讯，只不过监听emit过来的函数的是同级组件而已。所以这里不做过多的解释了。接下来说说，一个父组件中引用了多个子组件，如何来调用多个子组件中的方法呢。父组件调用多个子组件中的方法&lt;template> &lt;div id='childrenComponent'> &lt;el-tabs v-model="activeName"> &lt;el-tab-pane label="组件1" name="components1"> &lt;children-component1 :params='params' ref="components1">&lt;/children-component1> &lt;/el-tab-pane> &lt;el-tab-pane label="组件2" name="components2"> &lt;children-component2 :params='params' ref="components2">&lt;/children-component2> &lt;/el-tab-pane> &lt;el-tab-pane label="组件3" name="components3"> &lt;children-component3 :params='params' ref="components3">&lt;/children-component3> &lt;/el-tab-pane> &lt;/el-tabs> &lt;button @click='goChildren'>&lt;/button> &lt;/div> &lt;/template> &lt;script> import childrenComponent1 from './childrenComponent1.vue' //子组件的相对路径 import childrenComponent2 from './childrenComponent2.vue' //子组件的相对路径 import childrenComponent3 from './childrenComponent3.vue' //子组件的相对路径 export default { data(){ activeName:'freeLearnTotal', }, methods:{ goChildren(){ this.$refs.components2.要调用方法名() } }, components:{ 'children-component1':childrenComponent1, 'children-component2':childrenComponent2, 'children-component3':childrenComponent3 } } &lt;/script> ref=&quot;components2&quot;核心就是这个。this.$refs是所有组件的合集。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
        <tag>Vue通讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈js引用类型数据的浅拷贝和深拷贝]]></title>
    <url>%2Farchive%2Fjavascript_copy.html</url>
    <content type="text"><![CDATA[浅拷贝：你只能得到我的银行卡，但你却永远也得不到里面的钱！js的数据存储类型基础类型直接指向存储引用类型指向存储地址的指针引用类型的浅拷贝 var n={ a:1, b:2, c:3, d:"123" } var m=n 直接将引用类型数据赋值给其他变量，只是将n浅拷贝给了m，当n或者m中的任意属性改变，另一者也会随之改变。引用类型的伪深拷贝枚举法var n={ a:1, b:2, c:3, d:"123" } var m={} for(var i in n){ m[i]=n[i] } for in 只能遍历对象本身及原型链上可枚举的属性，所以并不能说是完全的拷贝，但是m和n的值是互不影响的。JSON.stringify()和JSON.parse()var m=JSON.parse(JSON.stringify(n)); 使用JSON.stringify()将对象JSON化在使用JSON.parse()将JSON格式转换为对象这也可以实现伪深拷贝.但这种方法也有个很大缺陷，就是会破坏原型链,并且无法拷贝属性值为function的属性,仅仅是单纯的复制。Object.assign()Object.assign()方法可以实现无嵌套对象的深拷贝，我来解释一下是什么意思，就是说Object.assign()仅仅对对象的最顶层属性进行了深拷贝，而潜逃的数组或对象，并没有实现深拷贝，而是浅拷贝。来举个栗子：var n={ a:1, b:2, c:3, d:"123", e:{ a:1, b:2, c:{ a:3 } } } var s; // 进行伪深拷贝， Object.assign(s,n); s.a='test'; console.log(s) console.log(n) s.e.a="ABC" console.log(s) console.log(n) 可以看出，s最顶层的属性值发生改变时，不会影响n的最顶层属性值，但是嵌套对象内的属性会同时修改。本人最常用的深拷贝const clone = (obj) => { var o if (typeof obj === 'object') { if (obj === null) { o = null } else { if (obj instanceof Array) { o = [] for (var i = 0, len = obj.length; i &lt; len; i++) { o.push(clone(obj[i])) } } else { o = {} for (var j in obj) { o[j] = clone(obj[j]) } } } } else { o = obj } return o } 这套拷贝基本可以实现深拷贝，当然如果对象结构不是很复杂，没有嵌套对象的话，还是建议使用Object.assign()。]]></content>
      <categories>
        <category>原生Javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Farchive%2FhelloWorld.html</url>
    <content type="text"><![CDATA[Hello World菜鸟FE，仅以此博客记录自己的生活和一些工作中遇到的技术问题。如遇大佬路过，还望手下留情！]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
  </entry>
</search>
